{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport store from '@/store';\nimport axios from 'axios';\nimport request from '@/utils/request';\nimport { Message } from 'element-ui';\nimport _vue from '@/main.js';\nconst reqList = new Map();\nconst loadingMap = new Map();\n// const socketResult = new Map()\n// const ws = ''\nconst handleGet = (url, query, cptId) => {\n  const reqUrl = `${url}?${new URLSearchParams(query).toString()}`;\n  return request({\n    url: reqUrl,\n    method: 'get',\n    cancelToken: new axios.CancelToken(c => {\n      reqList.set(cptId, c);\n    })\n  });\n};\nconst handlePost = (url, data, cptId) => {\n  return request({\n    url,\n    method: 'post',\n    data,\n    cancelToken: new axios.CancelToken(c => {\n      reqList.set(cptId, c);\n    })\n  });\n};\n/**\n *  文件下载\n * @param downloadUrl   文件\n * @param fileName      文件名\n */\nconst fileDownload = function (downloadUrl, fileName) {\n  const aLink = document.createElement('a');\n  aLink.style.display = 'none';\n  aLink.href = downloadUrl;\n  aLink.download = fileName;\n  document.body.appendChild(aLink);\n  aLink.click();\n  document.body.removeChild(aLink);\n};\nconst base64toFile = function (base64, fileName) {\n  const arr = base64.split(',');\n  const mime = arr[0].match(/:(.*?);/)[1];\n  const bstr = atob(arr[1]);\n  let n = bstr.length;\n  const u8arr = new Uint8Array(n);\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n  return new File([u8arr], fileName, {\n    type: mime\n  });\n};\nasync function getDataJson(cptDataForm, id) {\n  // 防止 JSON 解析报错\n  let res = '{}';\n  let currentCptRef = null;\n  let loading = false;\n  let iptStr = cptDataForm.dataText;\n  /**\n   * 数据源类型\n   * 静态数据 1\n   * 借接口数据 2\n   * sql 语句查询数据 3\n   * websocket 数据 4\n   */\n  const dataSource = cptDataForm.dataSource;\n  // 静态数据\n  if (dataSource === 1) {\n    res = JSON.parse(iptStr);\n  } else if (dataSource === 2) {\n    // 接口请求\n    const url = cptDataForm.apiUrl;\n    // 请求方式 GET POST\n    const reqType = cptDataForm.reqType;\n    // 请求参数\n    const paramsObj = store.state.bigScreen.reqParams[id];\n    if (url) {\n      if (reqList.has(id)) {\n        reqList.get(id)();\n        reqList.delete(id);\n      }\n      _vue.$nextTick(() => {\n        currentCptRef = store.state.bigScreen.cptRefs.get(id);\n        const {\n          loadingText,\n          loadingIcon,\n          maskColor\n        } = cptDataForm;\n        const loadingIsExist = loadingMap.has(id);\n        loading = cptDataForm.loading;\n        if (loading && loadingIsExist) {\n          loadingMap.get(id).close();\n          loadingMap.delete(id);\n        }\n        loading && loadingMap.set(id, _vue.$modal.loading(loadingText, currentCptRef.$el, loadingIcon, maskColor));\n      });\n      if (reqType === 'GET') {\n        res = await handleGet(url, paramsObj, id);\n      } else {\n        res = await handlePost(url, paramsObj, id);\n      }\n    } else {\n      Message.error('接口地址不能为空');\n    }\n  } else if (dataSource === 3) {\n    // sql 语句\n    iptStr = cptDataForm.sql;\n    if (iptStr) {\n      // todo res = sql 语句执行返回的数据\n      Message.closeAll();\n      Message.info('sql 查询功能暂未完成');\n    } else {\n      Message.error('SQL不能为空');\n    }\n  } else if (dataSource === 4) {\n    return Message.info('socket 测试中，暂不可用');\n    // // 如果已有值，则显示\n    // if (socketResult.has(id)) {\n    //   res = socketResult.get(id)\n    // } else {\n    //   // websocket\n    //   const path = `${cptDataForm.socketUrl}/${id}`\n    //   ws = new WebSocket(path)\n\n    //   /** readState\n    //    * CONNECTING：值为 0，表示正在连接。\n    //    * OPEN：值为 1，表示连接成功，可以通信了。\n    //    * CLOSING：值为 2，表示连接正在关闭。\n    //    * CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。\n    //    */\n\n    //   // 监听是否连接成功\n    //   ws.onopen = () => {\n    //     console.log('ws连接状态：' + ws.readyState)\n    //   }\n    //   // 接听服务器发回的信息并处理展示\n    //   ws.onmessage = (e) => {\n    //   // console.log('接收到来自服务器的消息：' + e.data)\n    //     socketResult.set(id, JSON.parse(e.data))\n    //   }\n    //   // 监听连接关闭事件\n    //   ws.onclose = () => {\n    //   // 监听整个过程中websocket的状态\n    //     console.log('ws连接状态：' + ws.readyState)\n    //     ws.send('连接关闭')\n    //   }\n    //   // 监听并处理报错事件\n    //   ws.onerror = (err) => {\n    //     console.log(err)\n    //   }\n    // }\n  }\n  // 处理数据函数\n  if (cptDataForm.convertData) {\n    const funcStr = cptDataForm.convertData;\n    const convertFun = new Function('return ' + funcStr);\n    if (currentCptRef) {\n      loading && loadingMap.get(id).close();\n      loading && loadingMap.delete(id);\n    }\n    return convertFun()(res);\n  } else {\n    if (currentCptRef) {\n      loading && loadingMap.get(id).close();\n      loading && loadingMap.delete(id);\n    }\n    return res;\n  }\n}\nconst cptTimers = {};\nfunction pollingRefresh(uuid, cptDataForm, loadData) {\n  if (uuid) {\n    // 清除旧的定时器\n    clearInterval(cptTimers[uuid]);\n  }\n  if (!cptDataForm) {\n    Message.warning('cptDataForm ==> null');\n    return;\n  }\n  if (!loadData) {\n    Message.warning('子组件未实现数据解析方法');\n    return;\n  }\n  loadData();\n  // 开启轮询\n  if (cptDataForm.pollTime && cptDataForm.pollTime !== 0) {\n    cptTimers[uuid] = setInterval(function () {\n      loadData();\n    }, cptDataForm.pollTime * 1000);\n  }\n}\nfunction clearCptInterval(uuid, clearAll) {\n  if (uuid) {\n    // 清除旧的定时器\n    clearInterval(cptTimers[uuid]);\n  }\n  if (clearAll) {\n    for (const key in cptTimers) {\n      clearInterval(cptTimers[key]);\n    }\n  }\n}\nexport { fileDownload, base64toFile, getDataJson, pollingRefresh, clearCptInterval };","map":null,"metadata":{},"sourceType":"module"}